#' @title Statistical tests for intergenic distance data
#'
#' @description Statistical tests for intergenic distance data
#'
#' @param GeneSetDistances A \code{tibble} with intergenic distances for the
#'                         different gene sets, as generated by the
#'                         \code{\link{dist2Neighbors}} function.
#' @param Universe Character string indicating which set should be considered
#'                  as the universe (or control set)
#' @param type Character vector indicating which test(s) to perform among:
#'             "ks", "wilcox", "indep", "resample"
#' @param R integer giving the number of resampling to perform for the
#'           resampling test (Default to 1e4)
#'
#' @importFrom magrittr %>%
#' @importFrom dplyr select rename slice transmute mutate pull
#'             group_by summarise bind_rows one_of
#' @importFrom reshape2 melt
#' @importFrom rlang .data !!
#' @importFrom tibble as_tibble
#'
#' @export
#'
#' @return A tibble with at least the following columns:
#' \itemize{
#'   \item GeneSet. Name of the gene set.
#'   \item Orientation. Orientation of the neighbor (same or opposite strand).
#'   \item Side. Upstream or Downstream.
#' }
#' and additional columns among:
#' \itemize{
#'   \item KS.pvalue. p-value of Kolmogorov-Smirnof test
#'   \item Wilcox.pvalue. p-value of Wilcoxon rank sum test (or Mann-Whitney U test).
#'   \item Independ.pvalue. p-value of the independance test
#'   \item Resample.pvalue. p-value from the resampling test.
#' }
#'
#' @section DETAILS:
#' The following tests are possible:
#' \itemize{
#'   \item Kolmogorov-Smirnov test. See \code{\link[stats]{ks.test}}.
#'         Although not adapted to integer values, it gives conservative
#'         p-values for large enough gene sets.
#'   \item Wilcoxon rank sum test (or Mann-Whithney U test).
#'         See \code{\link[stats]{wilcox.test}}.
#'   \item Independence test. See \code{\link[coin]{independence_test}}
#'         in the \code{coin} package
#'   \item resample. A test based on random resampling of the universe distances.
#' }
#'
#' @seealso \code{\link[stats]{ks.test}},
#'          \code{\link[stats]{wilcox.test}},
#'          \code{\link[coin]{independence_test}}
#'
#' @examples
#' #' ## Obtain gene neighborhood information:
#'   GeneNeighbors <- getGeneNeighborhood(Genegr)
#' ## Get a (random) set of (100) genes:
#'   set.seed(123)
#'   randGenes <- sample(names(Genegr), 100)
#' ## Create a set enriched for close upstream genes:
#'   GenePool <- GeneNeighbors[!is.na(GeneNeighbors$UpstreamDistance),]
#'   Proba <- (max(GenePool$UpstreamDistance)-GenePool$UpstreamDistance) /
#'              sum(max(GenePool$UpstreamDistance)-GenePool$UpstreamDistance)
#'   CloseUpstream <- sample(GenePool$GeneName, size = 100, prob = Proba)
#' ## Extract distances for this set of genes and for all genes :
#'  myGeneSets <- list("RandomGenes" = randGenes,
#'                     "CloseUpstream" = CloseUpstream,
#'                     "AllGenes" = GeneNeighbors$GeneName)
#'  distForGeneSets <- dist2Neighbors(GeneNeighbors,
#'                                    myGeneSets)
#' ## Test distances for random genes
#' distTests(distForGeneSets)


distTests <- function(GeneSetDistances,
                      Universe=NULL,
                      type=c("ks", "wilcox", "indep", "resample"),
                      R = 1e4) {

#-----------
# Check arguments
#-----------

## GeneSetDistances
if (!is.data.frame(GeneSetDistances)) {
    stop("GeneSetDistances should be a data frame")
}

if (!all(c("GeneName", "Neighbor", "Orientation",
           "Side", "Distance", "GeneSet") %in% colnames(GeneSetDistances))) {
    stop("GeneSet should have colums 'GeneName', 'Neighbor', 'Orientation', ",
         "'Side', 'Distance', and 'GeneSet'. See dist2Neighbors function.")
}


if (!is.character(Universe) || length(Universe)!=1) {
    stop("Universe should be a single character string")
}

if (!(Universe %in%
        unique(GeneSetDistances %>% dplyr::pull(.data$GeneSet)))) {
    stop("Universe was not found in GeneSet column")
}


#-----------
# Separate Gene sets from control/universe gene set
#-----------
gs <- dplyr::left_join(
    GeneSetDistances %>%
    dplyr::filter(.data$GeneSet != Universe) %>%
    dplyr::select(-.data$Neighbor) %>%
    dplyr::group_by(.data$GeneSet, .data$Side, .data$Orientation) %>%
    tidyr::nest(.key = "DistSet"),

    GeneSetDistances %>%
    dplyr::filter(.data$GeneSet == Universe) %>%
    dplyr::select(-.data$Neighbor, -.data$GeneSet) %>%
    dplyr::group_by(.data$Side, .data$Orientation) %>%
    tidyr::nest(.key = "DistUniv"),

    by = c("Side", "Orientation")
)

#-----------
# Function to calculate p-values
#-----------
#Kolmogorov-Smirnov
ksfun <- function(.x, .y) {
    suppressWarnings(
        ks.test(.x %>% dplyr::pull(.data$Distance),
                .y %>%
                    dplyr::filter(!(.data$GeneName %in% .x$GeneName)) %>%
                    dplyr::pull(.data$Distance),
                exact = FALSE)$p.value
        )
}

#Mann-Whitney U-test:
Utest <- function(.x, .y) {
    wilcox.test(.x %>% dplyr::pull(.data$Distance),
                .y %>%
                    dplyr::filter(!(.data$GeneName %in% .x$GeneName)) %>%
                    dplyr::pull(.data$Distance),
            paired = FALSE)$p.value
}

#coin independence test:
coinIndep <- function(.x, .y) {
    df <- dplyr::union(.x, .y) %>%
              dplyr::mutate(isInTestSet = .data$GeneName %in% .x$GeneName)
    coin::pvalue(coin::independence_test(df$Distance ~ df$isInTestSet))
}

# TODO: Evaluate the distributions of p-values on 10000 random gene sets

#-----------
# Add p-values to the table
#-----------

gs %<>%
    dplyr::mutate(KS.pvalue = purrr::map2_dbl(.x = .data$DistSet,
                                              .y = .data$DistUniv,
                                               ksfun),
                  Wilcox.pvalue = purrr::map2_dbl(.x = .data$DistSet,
                                                  .y = .data$DistUniv,
                                                  Utest),
                  Indep.pvalue = purrr::map2_dbl(.x = .data$DistSet,
                                                 .y = .data$DistUniv,
                                                 coinIndep))

## See https://robertamezquita.github.io/post/2017-05-23-using-map-with-generic-functions-like-t-test/
## https://stackoverflow.com/questions/35558766/purrr-map-a-t-test-onto-a-split-df
## https://community.rstudio.com/t/applying-dunn-test-using-purrr-map/15155

# sets<- GeneSetDistances %>%
#          dplyr::filter(.data$GeneSet!=Universe)
#
# univ <- GeneSetDistances %>%
#     dplyr::filter(.data$GeneSet==Universe)

# GeneSetDistances %>%
#     dplyr::group_by(.data$Side, .data$Orientation) %>%
#     dplyr::mutate(KS.pvalue = ks.test( .data %>%
#                                            dplyr::filter(GeneSet!=Universe) %>%
#                                            dplyr::pull(Distance),
#                                        .data %>%
#                                            dplyr::filter(GeneSet==Universe) %>%
#                                            dplyr::pull(Distance),
#                                        exact = FALSE)$p.value)
##OK problem here is that we mix all gene sets together.
## We could probably apply this with map
## See https://jennybc.github.io/purrr-tutorial/index.html

# replicate(R, sample.int(nrow(x)))
# https://stats.stackexchange.com/questions/247004/statistical-significance-of-difference-between-distances
# https://stats.stackexchange.com/questions/24300/how-to-resample-in-r-without-repeating-permutations
# https://websites.pmc.ucsc.edu/~mclapham/Rtips/resampling.htm
# http://danielnee.com/2015/01/random-permutation-tests/

}
