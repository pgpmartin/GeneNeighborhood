---
title: "The GeneNeighborhood package"
author: "Pascal GP Martin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The GeneNeighborhood package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

  The GeneNeighborhood package provides statistical and graphical tools to analyze the direct neighborhood of sets of genes (called the "focus genes"). Here, "direct neighborhood" means the first upstream and downstream gene neighbors. We're interested in evaluating if these neighbors are enriched for a specific orientation/configuration and/or if their distance to the focus genes is shorter or larger than expected by chance.   

The main questions that this package addresses are, for a given set of focus genes:  

* Are the upstream or downstream neighbors in a specific orientation? Do they tend to overlap the focus genes more than expected?  

* For non overlapping upstream or downstream neighbors, do they tend to be closer or farther from the focus genes than expected?  

* More generally, do annotations located in the vicinity of the focus genes reveal any pattern compared to other sets of genes?  


## Let's start

### Load libraries
Load the library:
```{r load libraries}
library(GeneNeighborhood)
```
   
Throughout this vignette, we will also use other packages:
```{r, message=FALSE, warning=FALSE}
library(GenomeInfoDb)
```


```{r load hidden libs, include = FALSE}
library(knitr)
library(dplyr)
library(reshape2)
library(GenomicRanges)
```
   
   
### Get some data

The GeneNeighborhood package provides a toy dataset named `Genegr` that is used in the README file on [Github](https://github.com/pgpmartin/GeneNeighborhood) and throughout the examples in the documentation of the functions.   

For a more realistic example, we will work on the Arabidopsis thaliana gene annotations. These are available as a package in Bioconducor:
```{r, message=FALSE, warning=FALSE}
library(TxDb.Athaliana.BioMart.plantsmart25)
```
If you can't find a Txdb package for your organism in [Bioconductor](http://bioconductor.org/packages/release/BiocViews.html#___TxDb) or [AnnotationHub](http://bioconductor.org/packages/release/bioc/html/AnnotationHub.html), it is relatively easy to create your own package, using for example the [GenomicFeatures](http://bioconductor.org/packages/release/bioc/html/GenomicFeatures.html) or the [ensembldb](http://bioconductor.org/packages/release/bioc/html/ensembldb.html) package. 
   
   
We get the gene annotations from the TxDb package using:
```{r}
gn <- genes(TxDb.Athaliana.BioMart.plantsmart25)
```
   
In order to limit the computation time but still work on a realistic example we keep the first 2 chromosomes:
```{r}
gn <- keepSeqlevels(gn, 1:2, pruning.mode = "coarse")
```
   This represents `r length(gn)` genes.
   
## Obtain information on the upstream/downstream genes

 The first step in our analysis consists in extracting from the `GRanges` object the information about the neighbors. While this might seem trivial (such as just using correctly the `precede` and `follow` functions from the [GenomicRanges](http://bioconductor.org/packages/release/bioc/html/GenomicRanges.html)), there is actually a variety of cases that can be encountered throughout the genome that makes things quickly complicated.  
 For now, the `GeneNeighborhood` package only analyzes genes that either don't overlap with any other genes (the easy case) or that overlap with only one other gene, as illustrated here:   
   
 ![](Fig_getGeneNeighborhood.png)
   
   
For each feature/gene, we extract information (orientation and distance, potential overlaps) about their upstream/downstream neighbors with:
```{r extract GeneNeighbors}
GeneNeighbors <- getGeneNeighborhood(gn)
```
  
<!-- TODO: discuss gene selection (e.g. focus on PolII transcribed genes.) -->

## Analyze the orientation of the genes' neighbors
  
We define a random set of 400 genes:
```{r define random genes}
set.seed(123) # for reproducibility
randGenes <- sample(names(gn), 400)
```
  
  
We extract statistics about the orientation of their neighbors using:
```{r NOS random genes, eval=FALSE}
## Neighbors Orientation Statistics:
NOS <- analyzeNeighborsOrientation(randGenes, 
                                   GeneNeighborhood = GeneNeighbors)
```
  
  
By default all genes are used as a universe and an enrichment test is performed.   
By default, the function also analyzes the *"other"* orientation which may be hard to interpret. We can remove this orientation using:
```{r NOS without other}
NOS <- analyzeNeighborsOrientation(randGenes, 
                                   GeneNeighborhood = GeneNeighbors,
                                   keepOther = FALSE)
```
  
  
We obtain the following table:
```{r NOS kable, echo = FALSE}
NOS  %>% 
  dplyr::mutate(p.value = signif(p.value, 2)) %>%
  knitr::kable(digits = c(1,1,1,2,1,2,300), 
               format = "markdown",
               caption="100 random genes")
```
  
  
We can plot the corresponding percentages using:
```{r plotOrientationNOS, fig.height = 4, fig.width = 5}
plotNeighborsOrientation(NOS)
```
  
  The analysis of neighbor genes'orientations allows to detect an enrichment for a specific orientation (*"SameStrand"* or *"OppositeStrand"*) in the absence of overlap, as well as the situations where the upstream or downstream gene overlaps with the focus genes (*"SameOverlap"*" or *"OppositeOverlap"*" orientations).   
  Even in the absence of enrichment for a specific situation, it might be relevant to evaluate if the gene neighbors are located at a specific distance from the focus genes, i.e. closer or farther than expected.  
  
  

## Analyze the proximity of the genes' neighbors
  
### Analysis of a random set of genes:  
  
Analyzing the distances of the upstream **or** downstream genes can be done with:
```{r randUpstreamDist, results = "hide"}
randUpstreamDist <- statDistanceSide(GeneNeighborhood = GeneNeighbors,
                                     glist = randGenes,
                                     Side = "Upstream")
```
  
Which gives the following (simplified) table:
```{r randUpstreamDist kable, echo = FALSE}
randUpstreamDist$stats  %>% 
  dplyr::select(GeneGroup, SideClass, n, Median, Mean, SD, KS.pvalue:Independ.pvalue) %>%
  dplyr::mutate(KS.pvalue = signif(KS.pvalue, 2),
                Wilcox.pvalue = signif(Wilcox.pvalue, 2),
                Independ.pvalue = signif(Independ.pvalue, 2)) %>%
  knitr::kable(digits = c(1,1,1,2,2,2,300,300,300), 
               format = "markdown",
               caption="Upstream distances of random genes")
```
  
  
  However, the analysis of **both** upstream and downstream genes with the `statDistanceSide` function is wrapped in the `analyzeNeighborsDistance` function: 
```{r randDist, results = "hide"}
randDist <- analyzeNeighborsDistance(GeneList = randGenes,
                                     GeneNeighborhood = GeneNeighbors)
```

We obtain the following (simplified) table:
```{r randDist kable, echo = FALSE}
randDist$stats  %>% 
  dplyr::select(GeneGroup:n, Median, Mean, SD, KS.pvalue:Independ.pvalue) %>%
  dplyr::mutate(KS.pvalue = signif(KS.pvalue, 2),
                Wilcox.pvalue = signif(Wilcox.pvalue, 2),
                Independ.pvalue = signif(Independ.pvalue, 2)) %>%
  knitr::kable(digits = c(1,1,1,1,2,2,2,300,300,300), 
               format = "markdown",
               caption="Upstream distances")
```
   
   
### Extracting intergenic distances:  

The `analyzeNeighborsDistance` function can also be used to extract intergenic distances for all genes (overlapping upstream or downstream genes are removed automatically here). To do this, we only set the `GeneList` argument to be all genes and set `DistriTest=FALSE`:
```{r alldist, results = "hide"}
alldist <- analyzeNeighborsDistance(GeneList = names(gn),
                                    GeneNeighborhood = GeneNeighbors,
                                    DistriTest = FALSE)
```
  
  
### Analyze a set of genes enriched for close upstream neighbors:
  To illustrate how a specific proximity pattern can be detected and represented, we use these intergenic distances to select a set of genes with more frequent short upstream distances than expected by chance, whatever the orientation (same or opposite strand).   
  
  First, we extract upstream distances:
```{r updist}
updist <- alldist$distances$Distance[alldist$distances$Side=="Upstream"]
names(updist) <- alldist$distances$GeneName[alldist$distances$Side=="Upstream"]
```
  Then we define a probability of selecting the gene that is inversely proportional to its upstream distance:
```{r probs}
updistQ <- pmin(updist, quantile(updist,0.99)) #We replace extreme values by the 99th percentile
probs <- (max(updistQ) - updistQ) / 
         sum(max(updistQ) - updistQ)
```
  Then we select 800 genes using these probabilities:
```{r lessRandGenes}
set.seed(123)
closeUpstreamNeighbors <- sample(names(updist), 800, prob=probs)
```
  And finally we analyze the intergenic distances with these genes' neighbors:
```{r lessRandDist, results = "hide"}
closeUpstreamDist <- analyzeNeighborsDistance(GeneList = closeUpstreamNeighbors,
                                              GeneNeighborhood = GeneNeighbors)
```
   
We obtain the following (simplified) table:
```{r lessRandDist kable, echo = FALSE}
closeUpstreamDist$stats  %>% 
  dplyr::select(GeneGroup:n, Median, Mean, SD, KS.pvalue:Independ.pvalue) %>%
  dplyr::mutate(KS.pvalue = signif(KS.pvalue, 2),
                Wilcox.pvalue = signif(Wilcox.pvalue, 2),
                Independ.pvalue = signif(Independ.pvalue, 2)) %>%
  knitr::kable(digits = c(1,1,1,1,2,2,2,300,300,300), 
               format = "markdown",
               caption="Upstream distances of close upstream neighbors")
```
   
   
### Plotting the results:
Before plotting, we need to assemble the distances for different groups of genes in a single data frame:
```{r mydist dataset}
mydist <- rbind.data.frame(alldist$distances,
                           randDist$distances,
                           closeUpstreamDist$distances)
mydist$GeneSet <- rep(c("All Genes", "Random Genes", "Close Upstream"),
                      times = c(nrow(alldist$distances), 
                                nrow(randDist$distances), 
                                nrow(closeUpstreamDist$distances)))
```
   
   
Now, we can plot the distribution of intergenic distances for these sets of genes:
```{r plotDistanceDistrib, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 7}
plotDistanceDistrib(mydist)
```


Or using violin plots:
```{r plotDistanceDistribViolin, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 7}
plotDistanceDistrib(mydist,
                    type = "violin")
```
