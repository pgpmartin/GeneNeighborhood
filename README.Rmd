---
output: github_document
---

[![Travis build status](https://travis-ci.com/pgpmartin/GeneNeighborhood.svg?branch=master)](https://travis-ci.com/pgpmartin/GeneNeighborhood)
[![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/pgpmartin/GeneNeighborhood?branch=master&svg=true)](https://ci.appveyor.com/project/pgpmartin/GeneNeighborhood)
[![Coverage status](https://codecov.io/gh/pgpmartin/GeneNeighborhood/branch/master/graph/badge.svg)](https://codecov.io/github/pgpmartin/GeneNeighborhood?branch=master)

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# GeneNeighborhood

The goal of GeneNeighborhood is to extract and analyze the orientation and proximity of upstream/downstream genes.

## Installation

(NOT THERE YET!) You can install the released version of GeneNeighborhood from [CRAN](https://CRAN.R-project.org) with:

``` r
install.packages("GeneNeighborhood")
```

And the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("pgpmartin/GeneNeighborhood")
```
## Example

Load the library:
```{r load libraries}
library(GeneNeighborhood)
```

```{r load hidden libs, include = FALSE}
library(knitr)
library(dplyr)
library(reshape2)
library(GenomicRanges)
```
  

### Obtain data on the gene neighbors

To run examples, the package includes a *GRanges* named **Genegr** that contains 676 genes with random coordinates on a single chromosome *Chr1*:
```{r gr data}
Genegr
```
  

For each feature/gene, we extract information (orientation and distance, potential overlaps) about their upstream/downstream neighbors with:
```{r extract GeneNeighbors}
GeneNeighbors <- getGeneNeighborhood(Genegr)
```
  

### Analyze the orientation of the genes' neighbors
  
We define a random set of 100 genes:
```{r define random genes}
set.seed(123)
randGenes <- sample(names(Genegr), 100)
```
  
  
We extract statistics about the orientation of their neighbors using:
```{r NOS random genes, results = "hide"}
## Neighbors Orientation Statistics:
NOS <- analyzeNeighborsOrientation(randGenes, 
                                   GeneNeighborhood = GeneNeighbors)
```
  
  
By default all genes are used as a universe and an enrichment test is performed.   
By default, the function also analyzes the *"other"* orientation which may be hard to interpret. We can remove this orientation using:
```{r NOS without other}
NOS <- analyzeNeighborsOrientation(randGenes, 
                                   GeneNeighborhood = GeneNeighbors,
                                   keepOther = FALSE)
```
  
  
We obtain the following table:
```{r NOS kable, echo = FALSE}
NOS  %>% 
  dplyr::mutate(p.value = signif(p.value, 2)) %>%
  knitr::kable(digits = c(1,1,1,2,1,2,300), 
               format = "markdown",
               caption="100 random genes")
```
  
  
We can plot the corresponding percentages using:
```{r plotOrientationNOS}
plotNeighborsOrientation(NOS)
```


### Analyze the proximity of the genes' neighbors

We can analyze specifically the distances to the upstream genes with:
```{r randUpstreamDist, results = "hide"}
randUpstreamDist <- statDistanceSide(GeneNeighborhood = GeneNeighbors,
                                     glist = randGenes,
                                     Side = "Upstream")
```

Which gives the following (simplified) table:
```{r randUpstreamDist kable, echo = FALSE}
randUpstreamDist$stats  %>% 
  dplyr::select(GeneGroup, SideClass, n, Median, Mean, SD, KS.pvalue:Independ.pvalue) %>%
  dplyr::mutate(KS.pvalue = signif(KS.pvalue, 2),
                Wilcox.pvalue = signif(Wilcox.pvalue, 2),
                Independ.pvalue = signif(Independ.pvalue, 2)) %>%
  knitr::kable(digits = c(1,1,1,2,2,2,300,300,300), 
               format = "markdown",
               caption="Upstream distances")
```
  
  
Or we directly analyze the distances to both upstream and downstream genes:
```{r randDist, results = "hide"}
randDist <- analyzeNeighborsDistance(GeneList = randGenes,
                                     GeneNeighborhood = GeneNeighbors)
```

Which gives the following (simplified) table:
```{r randDist kable, echo = FALSE}
randDist$stats  %>% 
  dplyr::select(GeneGroup:n, Median, Mean, SD, KS.pvalue:Independ.pvalue) %>%
  dplyr::mutate(KS.pvalue = signif(KS.pvalue, 2),
                Wilcox.pvalue = signif(Wilcox.pvalue, 2),
                Independ.pvalue = signif(Independ.pvalue, 2)) %>%
  knitr::kable(digits = c(1,1,1,1,2,2,2,300,300,300), 
               format = "markdown",
               caption="Upstream distances")
```
   
   
The function can also be used to extract intergenic distances for all genes (except those with overlapping genes):
```{r alldist, results = "hide"}
alldist <- analyzeNeighborsDistance(GeneList = names(Genegr),
                                    GeneNeighborhood = GeneNeighbors,
                                    DistriTest = FALSE)
```
   
   
   
We can use these distances to preferentially select genes with a short upstream distance.   
First, we extract upstream distances:
```{r updist}
updist <- alldist$distances$Distance[alldist$distances$Side=="Upstream"]
names(updist) <- alldist$distances$GeneName[alldist$distances$Side=="Upstream"]
```
Then we define a probability of selecting the gene that is inversely proportional to its upstream distance:
```{r probs}
probs <- (max(updist) - updist) / sum(max(updist) - updist)
```
Then select 100 genes using these probabilities:
```{r lessRandGenes}
set.seed(1234)
lessRandGenes <- sample(names(updist), 100, prob=probs)
```
And finally analyze the intergenic distances with these genes' neighbors:
```{r lessRandDist, results = "hide"}
lessRandDist <- analyzeNeighborsDistance(GeneList = lessRandGenes,
                                         GeneNeighborhood = GeneNeighbors)
```

We obtain the following (simplified) table:
```{r lessRandDist kable, echo = FALSE}
lessRandDist$stats  %>% 
  dplyr::select(GeneGroup:n, Median, Mean, SD, KS.pvalue:Independ.pvalue) %>%
  dplyr::mutate(KS.pvalue = signif(KS.pvalue, 2),
                Wilcox.pvalue = signif(Wilcox.pvalue, 2),
                Independ.pvalue = signif(Independ.pvalue, 2)) %>%
  knitr::kable(digits = c(1,1,1,1,2,2,2,300,300,300), 
               format = "markdown",
               caption="Upstream distances less random genes")
```
   
   
Before plotting, we need to assemble the distances for different groups of genes in a single data frame:
```{r mydist dataset}
mydist <- rbind.data.frame(alldist$distances,
                           randDist$distances,
                           lessRandDist$distances)
mydist$GeneSet <- rep(c("All Genes", "Random Genes", "Less Random genes"),
                      times = c(nrow(alldist$distances), 
                                nrow(randDist$distances), 
                                nrow(lessRandDist$distances)))
```
   
   
Now, we can plot the distribution of intergenic distances for these sets of genes:
```{r plotDistanceDensities, message = FALSE, warning = FALSE}
plotDistanceDensities(mydist)
```

   
   
### Metagene profiles
  
  Another way to study the neighborhood of a set of genes is to produce an average profiles representing the coverage of annotations in regions surrounding this set of genes. Such representation provides information on both the orientation and the distance of the neighbors. It also allows to compare different groups of genes (e.g. upregulated genes, genes with a ChIP-seq peak or a specific transcription factor motif in their promoter, etc...).   
  
  First we extract the profiles of annotations around (+/-50bp) all our "mock" genes.   
  We use 3 bins to summarize the coverage on the gene body so genes of size <3bp are removed.  
  We also use the argument *usePercent=TRUE* so that the profiles only indicate the presence/absence (0/1) of an annotation at a position rather than the number of genes that cover this position.
```{r annotationCoverageAroundFeatures}
usePercent = TRUE
Prof <- annotationCoverageAroundFeatures(Genegr,
                                         sidedist = 50,
                                         usePercent = usePercent,
                                         nbins=3)
```
  
  The object that is created by this function contains the following elements:
```{r, echo=FALSE}
cat(paste(names(Prof), collapse="\n"))
```
  They represent the strand-specific coverage of annotations on the gene body (*Feature*), in the region (-50bp to the start of the gene) located upstream of the genes (*UpstreamBorder*) and in the region (end of the gene to +50bp) located downstream of the genes (*DownstreamBorder*).   
  The *Sense* strand is the strand on which the focus gene (*Feature*) is annotated and the *Antisense* strand is the opposite strand.   
  Because we used *usePercent=TRUE*, the *Feature_Sense* profiles will only contain 1s, indicating the presence of annotation(s) all along the body of each focus gene (i.e. annotation of the focus gene itself). When *usePercent=FALSE*, values >1 can occur in these profile, when the focus gene overlaps with other genes annotated on the same strand.   
  
  Then, we assemble these different elements in order to produce a vector for each focus gene containing the upstream region (-50bp to the TSS), the gene body itself and the downstream region (TES to +50bp).  
```{r assembleProfiles}
Prof <- assembleProfiles(Prof)
```
  
  Now we define a group of genes that have neighbors, on the same strand, at a short distance.
```{r}
#Get distances to the closest gene on the same strand:
Dist2Nearest <- mcols(distanceToNearest(Genegr))$distance
CloseTandemNeighbors <- names(Genegr)[Dist2Nearest<=8]
```
  
  We assemble the different groups of genes that we have defined so far in a list:
```{r Assemble GeneGroups}
GeneGroups <- list(All = names(Genegr),
                   Random = randGenes,
                   CloseNeighbors = CloseTandemNeighbors)
```
  
  Then, for each group of genes, we calculate the average profile and its 95% confidence interval:
```{r getAvgProfileWithCI, message=FALSE}
avgProf <- list()
for (i in 1:length(GeneGroups)) {
  avgProf[[i]] <- list()
  avgProf[[i]]$sense <- getAvgProfileWithCI(Prof$Profiles_Sense,
                                            selFeatures = GeneGroups[[i]],
                                            pos = c(-50:0, 1:3, 0:50))
  avgProf[[i]]$antisense <- getAvgProfileWithCI(Prof$Profiles_Antisense,
                                                selFeatures = GeneGroups[[i]],
                                                pos = c(-50:0, 1:3, 0:50))
}
names(avgProf) <- names(GeneGroups)
```
  
  Before plotting, we need to assemble these profiles in a single table and to provide the x-coordinates for these "metagene" profiles (in the interval [0,5] with the gene body occupying coordinates ]2,3[).
```{r assemble metagene profiles}
#Define the x-coordinates (the 3 sequences correspond to "Upstream", "GeneBody" and "Downstream")
xcoord = c(seq(0, 2, length.out = 51),
           seq(2, 3, length.out = 5)[2:4],
           seq(3, 5, length.out = 51))
#Assemble the metagene profiles
avgProf_df <- reshape2::melt(avgProf,
                             measure.vars = "Profile", value.name = "Profile") %>%
                  dplyr::rename("Strand" = "L2",
                                "GeneSet" = "L1") %>%
                  dplyr::mutate(Xcoord=rep(xcoord, 2*length(GeneGroups)))
```
  
  Now we can plot these profiles using:
```{r plotMetageneProfile}
plotMetageneAnnotProfile(avgProf_df)
```

   
   
### Distance to single-point features
  
  One limitation of these average profiles is that all the length of the genes/features are taken into account to produce the profiles. Sometimes, we are interested only in one part of this information. For example, we may want to know how many genes (or what fraction of genes) have a TSS, on the same strand, at less than 20bp from their end? The metagene profiles above can provide an approximation but not the true value because some features actually start and end within this interval.
  The TSSs are *single-point features*. We can produce a coverage of the TSS using:
```{r tsscov}
#First obtain the coordinates of the TSS:
tss <- GenomicRanges::promoters(Genegr, upstream = 0, downstream = 1)
#Then the coverage of TSSs around (+/- 50bp) the genes
tsscov <- annotationCoverageAroundFeatures(annot = tss, 
                                           features = Genegr, 
                                           sidedist = 50, 
                                           usePercent = TRUE,
                                           nbins = 3)
```
But metagene plots as above will not work well because the data is too sparse.   
Instead, once a TSS is found at, say 5bp downstream of a gene border, we would like to extend its "presence" value (1) to any distance larger than 5bp to indicate that this specific gene has a TSS at less than any distance larger than 5. We do this using:
```{r extendPointPresence}
extTSScov <- extendPointPresence(tsscov, sidedist = 50)
```

Now for different groups of genes we can obtain the cumulative percentage of genes that have a TSS at less than a given distance with:
```{r getCumulPercentProfiles}
CP <- getCumulPercentProfiles(extTSScov,
                              genesets = GeneGroups)
```
   
   
  And plot the results with:
```{r plotCumulPercentProfile}
plotCumulPercentProfile(CP)
```
  
